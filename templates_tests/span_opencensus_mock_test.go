package templatestests

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_trace "go.opencensus.io/trace"
)

// SpanInterfaceMock implements trace.SpanInterface
type SpanInterfaceMock struct {
	t minimock.Tester

	funcAddAttributes          func(attributes ...mm_trace.Attribute)
	inspectFuncAddAttributes   func(attributes ...mm_trace.Attribute)
	afterAddAttributesCounter  uint64
	beforeAddAttributesCounter uint64
	AddAttributesMock          mSpanInterfaceMockAddAttributes

	funcAddLink          func(l mm_trace.Link)
	inspectFuncAddLink   func(l mm_trace.Link)
	afterAddLinkCounter  uint64
	beforeAddLinkCounter uint64
	AddLinkMock          mSpanInterfaceMockAddLink

	funcAddMessageReceiveEvent          func(messageID int64, uncompressedByteSize int64, compressedByteSize int64)
	inspectFuncAddMessageReceiveEvent   func(messageID int64, uncompressedByteSize int64, compressedByteSize int64)
	afterAddMessageReceiveEventCounter  uint64
	beforeAddMessageReceiveEventCounter uint64
	AddMessageReceiveEventMock          mSpanInterfaceMockAddMessageReceiveEvent

	funcAddMessageSendEvent          func(messageID int64, uncompressedByteSize int64, compressedByteSize int64)
	inspectFuncAddMessageSendEvent   func(messageID int64, uncompressedByteSize int64, compressedByteSize int64)
	afterAddMessageSendEventCounter  uint64
	beforeAddMessageSendEventCounter uint64
	AddMessageSendEventMock          mSpanInterfaceMockAddMessageSendEvent

	funcAnnotate          func(attributes []mm_trace.Attribute, str string)
	inspectFuncAnnotate   func(attributes []mm_trace.Attribute, str string)
	afterAnnotateCounter  uint64
	beforeAnnotateCounter uint64
	AnnotateMock          mSpanInterfaceMockAnnotate

	funcAnnotatef          func(attributes []mm_trace.Attribute, format string, a ...interface{})
	inspectFuncAnnotatef   func(attributes []mm_trace.Attribute, format string, a ...interface{})
	afterAnnotatefCounter  uint64
	beforeAnnotatefCounter uint64
	AnnotatefMock          mSpanInterfaceMockAnnotatef

	funcEnd          func()
	inspectFuncEnd   func()
	afterEndCounter  uint64
	beforeEndCounter uint64
	EndMock          mSpanInterfaceMockEnd

	funcIsRecordingEvents          func() (b1 bool)
	inspectFuncIsRecordingEvents   func()
	afterIsRecordingEventsCounter  uint64
	beforeIsRecordingEventsCounter uint64
	IsRecordingEventsMock          mSpanInterfaceMockIsRecordingEvents

	funcSetName          func(name string)
	inspectFuncSetName   func(name string)
	afterSetNameCounter  uint64
	beforeSetNameCounter uint64
	SetNameMock          mSpanInterfaceMockSetName

	funcSetStatus          func(status mm_trace.Status)
	inspectFuncSetStatus   func(status mm_trace.Status)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mSpanInterfaceMockSetStatus

	funcSpanContext          func() (s1 mm_trace.SpanContext)
	inspectFuncSpanContext   func()
	afterSpanContextCounter  uint64
	beforeSpanContextCounter uint64
	SpanContextMock          mSpanInterfaceMockSpanContext

	funcString          func() (s1 string)
	inspectFuncString   func()
	afterStringCounter  uint64
	beforeStringCounter uint64
	StringMock          mSpanInterfaceMockString
}

// NewSpanInterfaceMock returns a mock for trace.SpanInterface
func NewSpanInterfaceMock(t minimock.Tester) *SpanInterfaceMock {
	m := &SpanInterfaceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddAttributesMock = mSpanInterfaceMockAddAttributes{mock: m}
	m.AddAttributesMock.callArgs = []*SpanInterfaceMockAddAttributesParams{}

	m.AddLinkMock = mSpanInterfaceMockAddLink{mock: m}
	m.AddLinkMock.callArgs = []*SpanInterfaceMockAddLinkParams{}

	m.AddMessageReceiveEventMock = mSpanInterfaceMockAddMessageReceiveEvent{mock: m}
	m.AddMessageReceiveEventMock.callArgs = []*SpanInterfaceMockAddMessageReceiveEventParams{}

	m.AddMessageSendEventMock = mSpanInterfaceMockAddMessageSendEvent{mock: m}
	m.AddMessageSendEventMock.callArgs = []*SpanInterfaceMockAddMessageSendEventParams{}

	m.AnnotateMock = mSpanInterfaceMockAnnotate{mock: m}
	m.AnnotateMock.callArgs = []*SpanInterfaceMockAnnotateParams{}

	m.AnnotatefMock = mSpanInterfaceMockAnnotatef{mock: m}
	m.AnnotatefMock.callArgs = []*SpanInterfaceMockAnnotatefParams{}

	m.EndMock = mSpanInterfaceMockEnd{mock: m}

	m.IsRecordingEventsMock = mSpanInterfaceMockIsRecordingEvents{mock: m}

	m.SetNameMock = mSpanInterfaceMockSetName{mock: m}
	m.SetNameMock.callArgs = []*SpanInterfaceMockSetNameParams{}

	m.SetStatusMock = mSpanInterfaceMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*SpanInterfaceMockSetStatusParams{}

	m.SpanContextMock = mSpanInterfaceMockSpanContext{mock: m}

	m.StringMock = mSpanInterfaceMockString{mock: m}

	return m
}

type mSpanInterfaceMockAddAttributes struct {
	mock               *SpanInterfaceMock
	defaultExpectation *SpanInterfaceMockAddAttributesExpectation
	expectations       []*SpanInterfaceMockAddAttributesExpectation

	callArgs []*SpanInterfaceMockAddAttributesParams
	mutex    sync.RWMutex
}

// SpanInterfaceMockAddAttributesExpectation specifies expectation struct of the SpanInterface.AddAttributes
type SpanInterfaceMockAddAttributesExpectation struct {
	mock   *SpanInterfaceMock
	params *SpanInterfaceMockAddAttributesParams

	Counter uint64
}

// SpanInterfaceMockAddAttributesParams contains parameters of the SpanInterface.AddAttributes
type SpanInterfaceMockAddAttributesParams struct {
	attributes []mm_trace.Attribute
}

// Expect sets up expected params for SpanInterface.AddAttributes
func (mmAddAttributes *mSpanInterfaceMockAddAttributes) Expect(attributes ...mm_trace.Attribute) *mSpanInterfaceMockAddAttributes {
	if mmAddAttributes.mock.funcAddAttributes != nil {
		mmAddAttributes.mock.t.Fatalf("SpanInterfaceMock.AddAttributes mock is already set by Set")
	}

	if mmAddAttributes.defaultExpectation == nil {
		mmAddAttributes.defaultExpectation = &SpanInterfaceMockAddAttributesExpectation{}
	}

	mmAddAttributes.defaultExpectation.params = &SpanInterfaceMockAddAttributesParams{attributes}
	for _, e := range mmAddAttributes.expectations {
		if minimock.Equal(e.params, mmAddAttributes.defaultExpectation.params) {
			mmAddAttributes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddAttributes.defaultExpectation.params)
		}
	}

	return mmAddAttributes
}

// Inspect accepts an inspector function that has same arguments as the SpanInterface.AddAttributes
func (mmAddAttributes *mSpanInterfaceMockAddAttributes) Inspect(f func(attributes ...mm_trace.Attribute)) *mSpanInterfaceMockAddAttributes {
	if mmAddAttributes.mock.inspectFuncAddAttributes != nil {
		mmAddAttributes.mock.t.Fatalf("Inspect function is already set for SpanInterfaceMock.AddAttributes")
	}

	mmAddAttributes.mock.inspectFuncAddAttributes = f

	return mmAddAttributes
}

// Return sets up results that will be returned by SpanInterface.AddAttributes
func (mmAddAttributes *mSpanInterfaceMockAddAttributes) Return() *SpanInterfaceMock {
	if mmAddAttributes.mock.funcAddAttributes != nil {
		mmAddAttributes.mock.t.Fatalf("SpanInterfaceMock.AddAttributes mock is already set by Set")
	}

	if mmAddAttributes.defaultExpectation == nil {
		mmAddAttributes.defaultExpectation = &SpanInterfaceMockAddAttributesExpectation{mock: mmAddAttributes.mock}
	}

	return mmAddAttributes.mock
}

//Set uses given function f to mock the SpanInterface.AddAttributes method
func (mmAddAttributes *mSpanInterfaceMockAddAttributes) Set(f func(attributes ...mm_trace.Attribute)) *SpanInterfaceMock {
	if mmAddAttributes.defaultExpectation != nil {
		mmAddAttributes.mock.t.Fatalf("Default expectation is already set for the SpanInterface.AddAttributes method")
	}

	if len(mmAddAttributes.expectations) > 0 {
		mmAddAttributes.mock.t.Fatalf("Some expectations are already set for the SpanInterface.AddAttributes method")
	}

	mmAddAttributes.mock.funcAddAttributes = f
	return mmAddAttributes.mock
}

// AddAttributes implements trace.SpanInterface
func (mmAddAttributes *SpanInterfaceMock) AddAttributes(attributes ...mm_trace.Attribute) {
	mm_atomic.AddUint64(&mmAddAttributes.beforeAddAttributesCounter, 1)
	defer mm_atomic.AddUint64(&mmAddAttributes.afterAddAttributesCounter, 1)

	if mmAddAttributes.inspectFuncAddAttributes != nil {
		mmAddAttributes.inspectFuncAddAttributes(attributes...)
	}

	mm_params := &SpanInterfaceMockAddAttributesParams{attributes}

	// Record call args
	mmAddAttributes.AddAttributesMock.mutex.Lock()
	mmAddAttributes.AddAttributesMock.callArgs = append(mmAddAttributes.AddAttributesMock.callArgs, mm_params)
	mmAddAttributes.AddAttributesMock.mutex.Unlock()

	for _, e := range mmAddAttributes.AddAttributesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddAttributes.AddAttributesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddAttributes.AddAttributesMock.defaultExpectation.Counter, 1)
		mm_want := mmAddAttributes.AddAttributesMock.defaultExpectation.params
		mm_got := SpanInterfaceMockAddAttributesParams{attributes}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddAttributes.t.Errorf("SpanInterfaceMock.AddAttributes got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddAttributes.funcAddAttributes != nil {
		mmAddAttributes.funcAddAttributes(attributes...)
		return
	}
	mmAddAttributes.t.Fatalf("Unexpected call to SpanInterfaceMock.AddAttributes. %v", attributes)

}

// AddAttributesAfterCounter returns a count of finished SpanInterfaceMock.AddAttributes invocations
func (mmAddAttributes *SpanInterfaceMock) AddAttributesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAttributes.afterAddAttributesCounter)
}

// AddAttributesBeforeCounter returns a count of SpanInterfaceMock.AddAttributes invocations
func (mmAddAttributes *SpanInterfaceMock) AddAttributesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAttributes.beforeAddAttributesCounter)
}

// Calls returns a list of arguments used in each call to SpanInterfaceMock.AddAttributes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddAttributes *mSpanInterfaceMockAddAttributes) Calls() []*SpanInterfaceMockAddAttributesParams {
	mmAddAttributes.mutex.RLock()

	argCopy := make([]*SpanInterfaceMockAddAttributesParams, len(mmAddAttributes.callArgs))
	copy(argCopy, mmAddAttributes.callArgs)

	mmAddAttributes.mutex.RUnlock()

	return argCopy
}

// MinimockAddAttributesDone returns true if the count of the AddAttributes invocations corresponds
// the number of defined expectations
func (m *SpanInterfaceMock) MinimockAddAttributesDone() bool {
	for _, e := range m.AddAttributesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddAttributesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddAttributesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddAttributes != nil && mm_atomic.LoadUint64(&m.afterAddAttributesCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddAttributesInspect logs each unmet expectation
func (m *SpanInterfaceMock) MinimockAddAttributesInspect() {
	for _, e := range m.AddAttributesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpanInterfaceMock.AddAttributes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddAttributesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddAttributesCounter) < 1 {
		if m.AddAttributesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SpanInterfaceMock.AddAttributes")
		} else {
			m.t.Errorf("Expected call to SpanInterfaceMock.AddAttributes with params: %#v", *m.AddAttributesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddAttributes != nil && mm_atomic.LoadUint64(&m.afterAddAttributesCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.AddAttributes")
	}
}

type mSpanInterfaceMockAddLink struct {
	mock               *SpanInterfaceMock
	defaultExpectation *SpanInterfaceMockAddLinkExpectation
	expectations       []*SpanInterfaceMockAddLinkExpectation

	callArgs []*SpanInterfaceMockAddLinkParams
	mutex    sync.RWMutex
}

// SpanInterfaceMockAddLinkExpectation specifies expectation struct of the SpanInterface.AddLink
type SpanInterfaceMockAddLinkExpectation struct {
	mock   *SpanInterfaceMock
	params *SpanInterfaceMockAddLinkParams

	Counter uint64
}

// SpanInterfaceMockAddLinkParams contains parameters of the SpanInterface.AddLink
type SpanInterfaceMockAddLinkParams struct {
	l mm_trace.Link
}

// Expect sets up expected params for SpanInterface.AddLink
func (mmAddLink *mSpanInterfaceMockAddLink) Expect(l mm_trace.Link) *mSpanInterfaceMockAddLink {
	if mmAddLink.mock.funcAddLink != nil {
		mmAddLink.mock.t.Fatalf("SpanInterfaceMock.AddLink mock is already set by Set")
	}

	if mmAddLink.defaultExpectation == nil {
		mmAddLink.defaultExpectation = &SpanInterfaceMockAddLinkExpectation{}
	}

	mmAddLink.defaultExpectation.params = &SpanInterfaceMockAddLinkParams{l}
	for _, e := range mmAddLink.expectations {
		if minimock.Equal(e.params, mmAddLink.defaultExpectation.params) {
			mmAddLink.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddLink.defaultExpectation.params)
		}
	}

	return mmAddLink
}

// Inspect accepts an inspector function that has same arguments as the SpanInterface.AddLink
func (mmAddLink *mSpanInterfaceMockAddLink) Inspect(f func(l mm_trace.Link)) *mSpanInterfaceMockAddLink {
	if mmAddLink.mock.inspectFuncAddLink != nil {
		mmAddLink.mock.t.Fatalf("Inspect function is already set for SpanInterfaceMock.AddLink")
	}

	mmAddLink.mock.inspectFuncAddLink = f

	return mmAddLink
}

// Return sets up results that will be returned by SpanInterface.AddLink
func (mmAddLink *mSpanInterfaceMockAddLink) Return() *SpanInterfaceMock {
	if mmAddLink.mock.funcAddLink != nil {
		mmAddLink.mock.t.Fatalf("SpanInterfaceMock.AddLink mock is already set by Set")
	}

	if mmAddLink.defaultExpectation == nil {
		mmAddLink.defaultExpectation = &SpanInterfaceMockAddLinkExpectation{mock: mmAddLink.mock}
	}

	return mmAddLink.mock
}

//Set uses given function f to mock the SpanInterface.AddLink method
func (mmAddLink *mSpanInterfaceMockAddLink) Set(f func(l mm_trace.Link)) *SpanInterfaceMock {
	if mmAddLink.defaultExpectation != nil {
		mmAddLink.mock.t.Fatalf("Default expectation is already set for the SpanInterface.AddLink method")
	}

	if len(mmAddLink.expectations) > 0 {
		mmAddLink.mock.t.Fatalf("Some expectations are already set for the SpanInterface.AddLink method")
	}

	mmAddLink.mock.funcAddLink = f
	return mmAddLink.mock
}

// AddLink implements trace.SpanInterface
func (mmAddLink *SpanInterfaceMock) AddLink(l mm_trace.Link) {
	mm_atomic.AddUint64(&mmAddLink.beforeAddLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmAddLink.afterAddLinkCounter, 1)

	if mmAddLink.inspectFuncAddLink != nil {
		mmAddLink.inspectFuncAddLink(l)
	}

	mm_params := &SpanInterfaceMockAddLinkParams{l}

	// Record call args
	mmAddLink.AddLinkMock.mutex.Lock()
	mmAddLink.AddLinkMock.callArgs = append(mmAddLink.AddLinkMock.callArgs, mm_params)
	mmAddLink.AddLinkMock.mutex.Unlock()

	for _, e := range mmAddLink.AddLinkMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddLink.AddLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddLink.AddLinkMock.defaultExpectation.Counter, 1)
		mm_want := mmAddLink.AddLinkMock.defaultExpectation.params
		mm_got := SpanInterfaceMockAddLinkParams{l}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddLink.t.Errorf("SpanInterfaceMock.AddLink got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddLink.funcAddLink != nil {
		mmAddLink.funcAddLink(l)
		return
	}
	mmAddLink.t.Fatalf("Unexpected call to SpanInterfaceMock.AddLink. %v", l)

}

// AddLinkAfterCounter returns a count of finished SpanInterfaceMock.AddLink invocations
func (mmAddLink *SpanInterfaceMock) AddLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddLink.afterAddLinkCounter)
}

// AddLinkBeforeCounter returns a count of SpanInterfaceMock.AddLink invocations
func (mmAddLink *SpanInterfaceMock) AddLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddLink.beforeAddLinkCounter)
}

// Calls returns a list of arguments used in each call to SpanInterfaceMock.AddLink.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddLink *mSpanInterfaceMockAddLink) Calls() []*SpanInterfaceMockAddLinkParams {
	mmAddLink.mutex.RLock()

	argCopy := make([]*SpanInterfaceMockAddLinkParams, len(mmAddLink.callArgs))
	copy(argCopy, mmAddLink.callArgs)

	mmAddLink.mutex.RUnlock()

	return argCopy
}

// MinimockAddLinkDone returns true if the count of the AddLink invocations corresponds
// the number of defined expectations
func (m *SpanInterfaceMock) MinimockAddLinkDone() bool {
	for _, e := range m.AddLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddLinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddLink != nil && mm_atomic.LoadUint64(&m.afterAddLinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddLinkInspect logs each unmet expectation
func (m *SpanInterfaceMock) MinimockAddLinkInspect() {
	for _, e := range m.AddLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpanInterfaceMock.AddLink with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddLinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddLinkCounter) < 1 {
		if m.AddLinkMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SpanInterfaceMock.AddLink")
		} else {
			m.t.Errorf("Expected call to SpanInterfaceMock.AddLink with params: %#v", *m.AddLinkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddLink != nil && mm_atomic.LoadUint64(&m.afterAddLinkCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.AddLink")
	}
}

type mSpanInterfaceMockAddMessageReceiveEvent struct {
	mock               *SpanInterfaceMock
	defaultExpectation *SpanInterfaceMockAddMessageReceiveEventExpectation
	expectations       []*SpanInterfaceMockAddMessageReceiveEventExpectation

	callArgs []*SpanInterfaceMockAddMessageReceiveEventParams
	mutex    sync.RWMutex
}

// SpanInterfaceMockAddMessageReceiveEventExpectation specifies expectation struct of the SpanInterface.AddMessageReceiveEvent
type SpanInterfaceMockAddMessageReceiveEventExpectation struct {
	mock   *SpanInterfaceMock
	params *SpanInterfaceMockAddMessageReceiveEventParams

	Counter uint64
}

// SpanInterfaceMockAddMessageReceiveEventParams contains parameters of the SpanInterface.AddMessageReceiveEvent
type SpanInterfaceMockAddMessageReceiveEventParams struct {
	messageID            int64
	uncompressedByteSize int64
	compressedByteSize   int64
}

// Expect sets up expected params for SpanInterface.AddMessageReceiveEvent
func (mmAddMessageReceiveEvent *mSpanInterfaceMockAddMessageReceiveEvent) Expect(messageID int64, uncompressedByteSize int64, compressedByteSize int64) *mSpanInterfaceMockAddMessageReceiveEvent {
	if mmAddMessageReceiveEvent.mock.funcAddMessageReceiveEvent != nil {
		mmAddMessageReceiveEvent.mock.t.Fatalf("SpanInterfaceMock.AddMessageReceiveEvent mock is already set by Set")
	}

	if mmAddMessageReceiveEvent.defaultExpectation == nil {
		mmAddMessageReceiveEvent.defaultExpectation = &SpanInterfaceMockAddMessageReceiveEventExpectation{}
	}

	mmAddMessageReceiveEvent.defaultExpectation.params = &SpanInterfaceMockAddMessageReceiveEventParams{messageID, uncompressedByteSize, compressedByteSize}
	for _, e := range mmAddMessageReceiveEvent.expectations {
		if minimock.Equal(e.params, mmAddMessageReceiveEvent.defaultExpectation.params) {
			mmAddMessageReceiveEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddMessageReceiveEvent.defaultExpectation.params)
		}
	}

	return mmAddMessageReceiveEvent
}

// Inspect accepts an inspector function that has same arguments as the SpanInterface.AddMessageReceiveEvent
func (mmAddMessageReceiveEvent *mSpanInterfaceMockAddMessageReceiveEvent) Inspect(f func(messageID int64, uncompressedByteSize int64, compressedByteSize int64)) *mSpanInterfaceMockAddMessageReceiveEvent {
	if mmAddMessageReceiveEvent.mock.inspectFuncAddMessageReceiveEvent != nil {
		mmAddMessageReceiveEvent.mock.t.Fatalf("Inspect function is already set for SpanInterfaceMock.AddMessageReceiveEvent")
	}

	mmAddMessageReceiveEvent.mock.inspectFuncAddMessageReceiveEvent = f

	return mmAddMessageReceiveEvent
}

// Return sets up results that will be returned by SpanInterface.AddMessageReceiveEvent
func (mmAddMessageReceiveEvent *mSpanInterfaceMockAddMessageReceiveEvent) Return() *SpanInterfaceMock {
	if mmAddMessageReceiveEvent.mock.funcAddMessageReceiveEvent != nil {
		mmAddMessageReceiveEvent.mock.t.Fatalf("SpanInterfaceMock.AddMessageReceiveEvent mock is already set by Set")
	}

	if mmAddMessageReceiveEvent.defaultExpectation == nil {
		mmAddMessageReceiveEvent.defaultExpectation = &SpanInterfaceMockAddMessageReceiveEventExpectation{mock: mmAddMessageReceiveEvent.mock}
	}

	return mmAddMessageReceiveEvent.mock
}

//Set uses given function f to mock the SpanInterface.AddMessageReceiveEvent method
func (mmAddMessageReceiveEvent *mSpanInterfaceMockAddMessageReceiveEvent) Set(f func(messageID int64, uncompressedByteSize int64, compressedByteSize int64)) *SpanInterfaceMock {
	if mmAddMessageReceiveEvent.defaultExpectation != nil {
		mmAddMessageReceiveEvent.mock.t.Fatalf("Default expectation is already set for the SpanInterface.AddMessageReceiveEvent method")
	}

	if len(mmAddMessageReceiveEvent.expectations) > 0 {
		mmAddMessageReceiveEvent.mock.t.Fatalf("Some expectations are already set for the SpanInterface.AddMessageReceiveEvent method")
	}

	mmAddMessageReceiveEvent.mock.funcAddMessageReceiveEvent = f
	return mmAddMessageReceiveEvent.mock
}

// AddMessageReceiveEvent implements trace.SpanInterface
func (mmAddMessageReceiveEvent *SpanInterfaceMock) AddMessageReceiveEvent(messageID int64, uncompressedByteSize int64, compressedByteSize int64) {
	mm_atomic.AddUint64(&mmAddMessageReceiveEvent.beforeAddMessageReceiveEventCounter, 1)
	defer mm_atomic.AddUint64(&mmAddMessageReceiveEvent.afterAddMessageReceiveEventCounter, 1)

	if mmAddMessageReceiveEvent.inspectFuncAddMessageReceiveEvent != nil {
		mmAddMessageReceiveEvent.inspectFuncAddMessageReceiveEvent(messageID, uncompressedByteSize, compressedByteSize)
	}

	mm_params := &SpanInterfaceMockAddMessageReceiveEventParams{messageID, uncompressedByteSize, compressedByteSize}

	// Record call args
	mmAddMessageReceiveEvent.AddMessageReceiveEventMock.mutex.Lock()
	mmAddMessageReceiveEvent.AddMessageReceiveEventMock.callArgs = append(mmAddMessageReceiveEvent.AddMessageReceiveEventMock.callArgs, mm_params)
	mmAddMessageReceiveEvent.AddMessageReceiveEventMock.mutex.Unlock()

	for _, e := range mmAddMessageReceiveEvent.AddMessageReceiveEventMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddMessageReceiveEvent.AddMessageReceiveEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddMessageReceiveEvent.AddMessageReceiveEventMock.defaultExpectation.Counter, 1)
		mm_want := mmAddMessageReceiveEvent.AddMessageReceiveEventMock.defaultExpectation.params
		mm_got := SpanInterfaceMockAddMessageReceiveEventParams{messageID, uncompressedByteSize, compressedByteSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddMessageReceiveEvent.t.Errorf("SpanInterfaceMock.AddMessageReceiveEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddMessageReceiveEvent.funcAddMessageReceiveEvent != nil {
		mmAddMessageReceiveEvent.funcAddMessageReceiveEvent(messageID, uncompressedByteSize, compressedByteSize)
		return
	}
	mmAddMessageReceiveEvent.t.Fatalf("Unexpected call to SpanInterfaceMock.AddMessageReceiveEvent. %v %v %v", messageID, uncompressedByteSize, compressedByteSize)

}

// AddMessageReceiveEventAfterCounter returns a count of finished SpanInterfaceMock.AddMessageReceiveEvent invocations
func (mmAddMessageReceiveEvent *SpanInterfaceMock) AddMessageReceiveEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageReceiveEvent.afterAddMessageReceiveEventCounter)
}

// AddMessageReceiveEventBeforeCounter returns a count of SpanInterfaceMock.AddMessageReceiveEvent invocations
func (mmAddMessageReceiveEvent *SpanInterfaceMock) AddMessageReceiveEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageReceiveEvent.beforeAddMessageReceiveEventCounter)
}

// Calls returns a list of arguments used in each call to SpanInterfaceMock.AddMessageReceiveEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddMessageReceiveEvent *mSpanInterfaceMockAddMessageReceiveEvent) Calls() []*SpanInterfaceMockAddMessageReceiveEventParams {
	mmAddMessageReceiveEvent.mutex.RLock()

	argCopy := make([]*SpanInterfaceMockAddMessageReceiveEventParams, len(mmAddMessageReceiveEvent.callArgs))
	copy(argCopy, mmAddMessageReceiveEvent.callArgs)

	mmAddMessageReceiveEvent.mutex.RUnlock()

	return argCopy
}

// MinimockAddMessageReceiveEventDone returns true if the count of the AddMessageReceiveEvent invocations corresponds
// the number of defined expectations
func (m *SpanInterfaceMock) MinimockAddMessageReceiveEventDone() bool {
	for _, e := range m.AddMessageReceiveEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMessageReceiveEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddMessageReceiveEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddMessageReceiveEvent != nil && mm_atomic.LoadUint64(&m.afterAddMessageReceiveEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddMessageReceiveEventInspect logs each unmet expectation
func (m *SpanInterfaceMock) MinimockAddMessageReceiveEventInspect() {
	for _, e := range m.AddMessageReceiveEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpanInterfaceMock.AddMessageReceiveEvent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMessageReceiveEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddMessageReceiveEventCounter) < 1 {
		if m.AddMessageReceiveEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SpanInterfaceMock.AddMessageReceiveEvent")
		} else {
			m.t.Errorf("Expected call to SpanInterfaceMock.AddMessageReceiveEvent with params: %#v", *m.AddMessageReceiveEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddMessageReceiveEvent != nil && mm_atomic.LoadUint64(&m.afterAddMessageReceiveEventCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.AddMessageReceiveEvent")
	}
}

type mSpanInterfaceMockAddMessageSendEvent struct {
	mock               *SpanInterfaceMock
	defaultExpectation *SpanInterfaceMockAddMessageSendEventExpectation
	expectations       []*SpanInterfaceMockAddMessageSendEventExpectation

	callArgs []*SpanInterfaceMockAddMessageSendEventParams
	mutex    sync.RWMutex
}

// SpanInterfaceMockAddMessageSendEventExpectation specifies expectation struct of the SpanInterface.AddMessageSendEvent
type SpanInterfaceMockAddMessageSendEventExpectation struct {
	mock   *SpanInterfaceMock
	params *SpanInterfaceMockAddMessageSendEventParams

	Counter uint64
}

// SpanInterfaceMockAddMessageSendEventParams contains parameters of the SpanInterface.AddMessageSendEvent
type SpanInterfaceMockAddMessageSendEventParams struct {
	messageID            int64
	uncompressedByteSize int64
	compressedByteSize   int64
}

// Expect sets up expected params for SpanInterface.AddMessageSendEvent
func (mmAddMessageSendEvent *mSpanInterfaceMockAddMessageSendEvent) Expect(messageID int64, uncompressedByteSize int64, compressedByteSize int64) *mSpanInterfaceMockAddMessageSendEvent {
	if mmAddMessageSendEvent.mock.funcAddMessageSendEvent != nil {
		mmAddMessageSendEvent.mock.t.Fatalf("SpanInterfaceMock.AddMessageSendEvent mock is already set by Set")
	}

	if mmAddMessageSendEvent.defaultExpectation == nil {
		mmAddMessageSendEvent.defaultExpectation = &SpanInterfaceMockAddMessageSendEventExpectation{}
	}

	mmAddMessageSendEvent.defaultExpectation.params = &SpanInterfaceMockAddMessageSendEventParams{messageID, uncompressedByteSize, compressedByteSize}
	for _, e := range mmAddMessageSendEvent.expectations {
		if minimock.Equal(e.params, mmAddMessageSendEvent.defaultExpectation.params) {
			mmAddMessageSendEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddMessageSendEvent.defaultExpectation.params)
		}
	}

	return mmAddMessageSendEvent
}

// Inspect accepts an inspector function that has same arguments as the SpanInterface.AddMessageSendEvent
func (mmAddMessageSendEvent *mSpanInterfaceMockAddMessageSendEvent) Inspect(f func(messageID int64, uncompressedByteSize int64, compressedByteSize int64)) *mSpanInterfaceMockAddMessageSendEvent {
	if mmAddMessageSendEvent.mock.inspectFuncAddMessageSendEvent != nil {
		mmAddMessageSendEvent.mock.t.Fatalf("Inspect function is already set for SpanInterfaceMock.AddMessageSendEvent")
	}

	mmAddMessageSendEvent.mock.inspectFuncAddMessageSendEvent = f

	return mmAddMessageSendEvent
}

// Return sets up results that will be returned by SpanInterface.AddMessageSendEvent
func (mmAddMessageSendEvent *mSpanInterfaceMockAddMessageSendEvent) Return() *SpanInterfaceMock {
	if mmAddMessageSendEvent.mock.funcAddMessageSendEvent != nil {
		mmAddMessageSendEvent.mock.t.Fatalf("SpanInterfaceMock.AddMessageSendEvent mock is already set by Set")
	}

	if mmAddMessageSendEvent.defaultExpectation == nil {
		mmAddMessageSendEvent.defaultExpectation = &SpanInterfaceMockAddMessageSendEventExpectation{mock: mmAddMessageSendEvent.mock}
	}

	return mmAddMessageSendEvent.mock
}

//Set uses given function f to mock the SpanInterface.AddMessageSendEvent method
func (mmAddMessageSendEvent *mSpanInterfaceMockAddMessageSendEvent) Set(f func(messageID int64, uncompressedByteSize int64, compressedByteSize int64)) *SpanInterfaceMock {
	if mmAddMessageSendEvent.defaultExpectation != nil {
		mmAddMessageSendEvent.mock.t.Fatalf("Default expectation is already set for the SpanInterface.AddMessageSendEvent method")
	}

	if len(mmAddMessageSendEvent.expectations) > 0 {
		mmAddMessageSendEvent.mock.t.Fatalf("Some expectations are already set for the SpanInterface.AddMessageSendEvent method")
	}

	mmAddMessageSendEvent.mock.funcAddMessageSendEvent = f
	return mmAddMessageSendEvent.mock
}

// AddMessageSendEvent implements trace.SpanInterface
func (mmAddMessageSendEvent *SpanInterfaceMock) AddMessageSendEvent(messageID int64, uncompressedByteSize int64, compressedByteSize int64) {
	mm_atomic.AddUint64(&mmAddMessageSendEvent.beforeAddMessageSendEventCounter, 1)
	defer mm_atomic.AddUint64(&mmAddMessageSendEvent.afterAddMessageSendEventCounter, 1)

	if mmAddMessageSendEvent.inspectFuncAddMessageSendEvent != nil {
		mmAddMessageSendEvent.inspectFuncAddMessageSendEvent(messageID, uncompressedByteSize, compressedByteSize)
	}

	mm_params := &SpanInterfaceMockAddMessageSendEventParams{messageID, uncompressedByteSize, compressedByteSize}

	// Record call args
	mmAddMessageSendEvent.AddMessageSendEventMock.mutex.Lock()
	mmAddMessageSendEvent.AddMessageSendEventMock.callArgs = append(mmAddMessageSendEvent.AddMessageSendEventMock.callArgs, mm_params)
	mmAddMessageSendEvent.AddMessageSendEventMock.mutex.Unlock()

	for _, e := range mmAddMessageSendEvent.AddMessageSendEventMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddMessageSendEvent.AddMessageSendEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddMessageSendEvent.AddMessageSendEventMock.defaultExpectation.Counter, 1)
		mm_want := mmAddMessageSendEvent.AddMessageSendEventMock.defaultExpectation.params
		mm_got := SpanInterfaceMockAddMessageSendEventParams{messageID, uncompressedByteSize, compressedByteSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddMessageSendEvent.t.Errorf("SpanInterfaceMock.AddMessageSendEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddMessageSendEvent.funcAddMessageSendEvent != nil {
		mmAddMessageSendEvent.funcAddMessageSendEvent(messageID, uncompressedByteSize, compressedByteSize)
		return
	}
	mmAddMessageSendEvent.t.Fatalf("Unexpected call to SpanInterfaceMock.AddMessageSendEvent. %v %v %v", messageID, uncompressedByteSize, compressedByteSize)

}

// AddMessageSendEventAfterCounter returns a count of finished SpanInterfaceMock.AddMessageSendEvent invocations
func (mmAddMessageSendEvent *SpanInterfaceMock) AddMessageSendEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageSendEvent.afterAddMessageSendEventCounter)
}

// AddMessageSendEventBeforeCounter returns a count of SpanInterfaceMock.AddMessageSendEvent invocations
func (mmAddMessageSendEvent *SpanInterfaceMock) AddMessageSendEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageSendEvent.beforeAddMessageSendEventCounter)
}

// Calls returns a list of arguments used in each call to SpanInterfaceMock.AddMessageSendEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddMessageSendEvent *mSpanInterfaceMockAddMessageSendEvent) Calls() []*SpanInterfaceMockAddMessageSendEventParams {
	mmAddMessageSendEvent.mutex.RLock()

	argCopy := make([]*SpanInterfaceMockAddMessageSendEventParams, len(mmAddMessageSendEvent.callArgs))
	copy(argCopy, mmAddMessageSendEvent.callArgs)

	mmAddMessageSendEvent.mutex.RUnlock()

	return argCopy
}

// MinimockAddMessageSendEventDone returns true if the count of the AddMessageSendEvent invocations corresponds
// the number of defined expectations
func (m *SpanInterfaceMock) MinimockAddMessageSendEventDone() bool {
	for _, e := range m.AddMessageSendEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMessageSendEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddMessageSendEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddMessageSendEvent != nil && mm_atomic.LoadUint64(&m.afterAddMessageSendEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddMessageSendEventInspect logs each unmet expectation
func (m *SpanInterfaceMock) MinimockAddMessageSendEventInspect() {
	for _, e := range m.AddMessageSendEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpanInterfaceMock.AddMessageSendEvent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMessageSendEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddMessageSendEventCounter) < 1 {
		if m.AddMessageSendEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SpanInterfaceMock.AddMessageSendEvent")
		} else {
			m.t.Errorf("Expected call to SpanInterfaceMock.AddMessageSendEvent with params: %#v", *m.AddMessageSendEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddMessageSendEvent != nil && mm_atomic.LoadUint64(&m.afterAddMessageSendEventCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.AddMessageSendEvent")
	}
}

type mSpanInterfaceMockAnnotate struct {
	mock               *SpanInterfaceMock
	defaultExpectation *SpanInterfaceMockAnnotateExpectation
	expectations       []*SpanInterfaceMockAnnotateExpectation

	callArgs []*SpanInterfaceMockAnnotateParams
	mutex    sync.RWMutex
}

// SpanInterfaceMockAnnotateExpectation specifies expectation struct of the SpanInterface.Annotate
type SpanInterfaceMockAnnotateExpectation struct {
	mock   *SpanInterfaceMock
	params *SpanInterfaceMockAnnotateParams

	Counter uint64
}

// SpanInterfaceMockAnnotateParams contains parameters of the SpanInterface.Annotate
type SpanInterfaceMockAnnotateParams struct {
	attributes []mm_trace.Attribute
	str        string
}

// Expect sets up expected params for SpanInterface.Annotate
func (mmAnnotate *mSpanInterfaceMockAnnotate) Expect(attributes []mm_trace.Attribute, str string) *mSpanInterfaceMockAnnotate {
	if mmAnnotate.mock.funcAnnotate != nil {
		mmAnnotate.mock.t.Fatalf("SpanInterfaceMock.Annotate mock is already set by Set")
	}

	if mmAnnotate.defaultExpectation == nil {
		mmAnnotate.defaultExpectation = &SpanInterfaceMockAnnotateExpectation{}
	}

	mmAnnotate.defaultExpectation.params = &SpanInterfaceMockAnnotateParams{attributes, str}
	for _, e := range mmAnnotate.expectations {
		if minimock.Equal(e.params, mmAnnotate.defaultExpectation.params) {
			mmAnnotate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAnnotate.defaultExpectation.params)
		}
	}

	return mmAnnotate
}

// Inspect accepts an inspector function that has same arguments as the SpanInterface.Annotate
func (mmAnnotate *mSpanInterfaceMockAnnotate) Inspect(f func(attributes []mm_trace.Attribute, str string)) *mSpanInterfaceMockAnnotate {
	if mmAnnotate.mock.inspectFuncAnnotate != nil {
		mmAnnotate.mock.t.Fatalf("Inspect function is already set for SpanInterfaceMock.Annotate")
	}

	mmAnnotate.mock.inspectFuncAnnotate = f

	return mmAnnotate
}

// Return sets up results that will be returned by SpanInterface.Annotate
func (mmAnnotate *mSpanInterfaceMockAnnotate) Return() *SpanInterfaceMock {
	if mmAnnotate.mock.funcAnnotate != nil {
		mmAnnotate.mock.t.Fatalf("SpanInterfaceMock.Annotate mock is already set by Set")
	}

	if mmAnnotate.defaultExpectation == nil {
		mmAnnotate.defaultExpectation = &SpanInterfaceMockAnnotateExpectation{mock: mmAnnotate.mock}
	}

	return mmAnnotate.mock
}

//Set uses given function f to mock the SpanInterface.Annotate method
func (mmAnnotate *mSpanInterfaceMockAnnotate) Set(f func(attributes []mm_trace.Attribute, str string)) *SpanInterfaceMock {
	if mmAnnotate.defaultExpectation != nil {
		mmAnnotate.mock.t.Fatalf("Default expectation is already set for the SpanInterface.Annotate method")
	}

	if len(mmAnnotate.expectations) > 0 {
		mmAnnotate.mock.t.Fatalf("Some expectations are already set for the SpanInterface.Annotate method")
	}

	mmAnnotate.mock.funcAnnotate = f
	return mmAnnotate.mock
}

// Annotate implements trace.SpanInterface
func (mmAnnotate *SpanInterfaceMock) Annotate(attributes []mm_trace.Attribute, str string) {
	mm_atomic.AddUint64(&mmAnnotate.beforeAnnotateCounter, 1)
	defer mm_atomic.AddUint64(&mmAnnotate.afterAnnotateCounter, 1)

	if mmAnnotate.inspectFuncAnnotate != nil {
		mmAnnotate.inspectFuncAnnotate(attributes, str)
	}

	mm_params := &SpanInterfaceMockAnnotateParams{attributes, str}

	// Record call args
	mmAnnotate.AnnotateMock.mutex.Lock()
	mmAnnotate.AnnotateMock.callArgs = append(mmAnnotate.AnnotateMock.callArgs, mm_params)
	mmAnnotate.AnnotateMock.mutex.Unlock()

	for _, e := range mmAnnotate.AnnotateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAnnotate.AnnotateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAnnotate.AnnotateMock.defaultExpectation.Counter, 1)
		mm_want := mmAnnotate.AnnotateMock.defaultExpectation.params
		mm_got := SpanInterfaceMockAnnotateParams{attributes, str}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAnnotate.t.Errorf("SpanInterfaceMock.Annotate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAnnotate.funcAnnotate != nil {
		mmAnnotate.funcAnnotate(attributes, str)
		return
	}
	mmAnnotate.t.Fatalf("Unexpected call to SpanInterfaceMock.Annotate. %v %v", attributes, str)

}

// AnnotateAfterCounter returns a count of finished SpanInterfaceMock.Annotate invocations
func (mmAnnotate *SpanInterfaceMock) AnnotateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAnnotate.afterAnnotateCounter)
}

// AnnotateBeforeCounter returns a count of SpanInterfaceMock.Annotate invocations
func (mmAnnotate *SpanInterfaceMock) AnnotateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAnnotate.beforeAnnotateCounter)
}

// Calls returns a list of arguments used in each call to SpanInterfaceMock.Annotate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAnnotate *mSpanInterfaceMockAnnotate) Calls() []*SpanInterfaceMockAnnotateParams {
	mmAnnotate.mutex.RLock()

	argCopy := make([]*SpanInterfaceMockAnnotateParams, len(mmAnnotate.callArgs))
	copy(argCopy, mmAnnotate.callArgs)

	mmAnnotate.mutex.RUnlock()

	return argCopy
}

// MinimockAnnotateDone returns true if the count of the Annotate invocations corresponds
// the number of defined expectations
func (m *SpanInterfaceMock) MinimockAnnotateDone() bool {
	for _, e := range m.AnnotateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AnnotateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAnnotateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAnnotate != nil && mm_atomic.LoadUint64(&m.afterAnnotateCounter) < 1 {
		return false
	}
	return true
}

// MinimockAnnotateInspect logs each unmet expectation
func (m *SpanInterfaceMock) MinimockAnnotateInspect() {
	for _, e := range m.AnnotateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpanInterfaceMock.Annotate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AnnotateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAnnotateCounter) < 1 {
		if m.AnnotateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SpanInterfaceMock.Annotate")
		} else {
			m.t.Errorf("Expected call to SpanInterfaceMock.Annotate with params: %#v", *m.AnnotateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAnnotate != nil && mm_atomic.LoadUint64(&m.afterAnnotateCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.Annotate")
	}
}

type mSpanInterfaceMockAnnotatef struct {
	mock               *SpanInterfaceMock
	defaultExpectation *SpanInterfaceMockAnnotatefExpectation
	expectations       []*SpanInterfaceMockAnnotatefExpectation

	callArgs []*SpanInterfaceMockAnnotatefParams
	mutex    sync.RWMutex
}

// SpanInterfaceMockAnnotatefExpectation specifies expectation struct of the SpanInterface.Annotatef
type SpanInterfaceMockAnnotatefExpectation struct {
	mock   *SpanInterfaceMock
	params *SpanInterfaceMockAnnotatefParams

	Counter uint64
}

// SpanInterfaceMockAnnotatefParams contains parameters of the SpanInterface.Annotatef
type SpanInterfaceMockAnnotatefParams struct {
	attributes []mm_trace.Attribute
	format     string
	a          []interface{}
}

// Expect sets up expected params for SpanInterface.Annotatef
func (mmAnnotatef *mSpanInterfaceMockAnnotatef) Expect(attributes []mm_trace.Attribute, format string, a ...interface{}) *mSpanInterfaceMockAnnotatef {
	if mmAnnotatef.mock.funcAnnotatef != nil {
		mmAnnotatef.mock.t.Fatalf("SpanInterfaceMock.Annotatef mock is already set by Set")
	}

	if mmAnnotatef.defaultExpectation == nil {
		mmAnnotatef.defaultExpectation = &SpanInterfaceMockAnnotatefExpectation{}
	}

	mmAnnotatef.defaultExpectation.params = &SpanInterfaceMockAnnotatefParams{attributes, format, a}
	for _, e := range mmAnnotatef.expectations {
		if minimock.Equal(e.params, mmAnnotatef.defaultExpectation.params) {
			mmAnnotatef.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAnnotatef.defaultExpectation.params)
		}
	}

	return mmAnnotatef
}

// Inspect accepts an inspector function that has same arguments as the SpanInterface.Annotatef
func (mmAnnotatef *mSpanInterfaceMockAnnotatef) Inspect(f func(attributes []mm_trace.Attribute, format string, a ...interface{})) *mSpanInterfaceMockAnnotatef {
	if mmAnnotatef.mock.inspectFuncAnnotatef != nil {
		mmAnnotatef.mock.t.Fatalf("Inspect function is already set for SpanInterfaceMock.Annotatef")
	}

	mmAnnotatef.mock.inspectFuncAnnotatef = f

	return mmAnnotatef
}

// Return sets up results that will be returned by SpanInterface.Annotatef
func (mmAnnotatef *mSpanInterfaceMockAnnotatef) Return() *SpanInterfaceMock {
	if mmAnnotatef.mock.funcAnnotatef != nil {
		mmAnnotatef.mock.t.Fatalf("SpanInterfaceMock.Annotatef mock is already set by Set")
	}

	if mmAnnotatef.defaultExpectation == nil {
		mmAnnotatef.defaultExpectation = &SpanInterfaceMockAnnotatefExpectation{mock: mmAnnotatef.mock}
	}

	return mmAnnotatef.mock
}

//Set uses given function f to mock the SpanInterface.Annotatef method
func (mmAnnotatef *mSpanInterfaceMockAnnotatef) Set(f func(attributes []mm_trace.Attribute, format string, a ...interface{})) *SpanInterfaceMock {
	if mmAnnotatef.defaultExpectation != nil {
		mmAnnotatef.mock.t.Fatalf("Default expectation is already set for the SpanInterface.Annotatef method")
	}

	if len(mmAnnotatef.expectations) > 0 {
		mmAnnotatef.mock.t.Fatalf("Some expectations are already set for the SpanInterface.Annotatef method")
	}

	mmAnnotatef.mock.funcAnnotatef = f
	return mmAnnotatef.mock
}

// Annotatef implements trace.SpanInterface
func (mmAnnotatef *SpanInterfaceMock) Annotatef(attributes []mm_trace.Attribute, format string, a ...interface{}) {
	mm_atomic.AddUint64(&mmAnnotatef.beforeAnnotatefCounter, 1)
	defer mm_atomic.AddUint64(&mmAnnotatef.afterAnnotatefCounter, 1)

	if mmAnnotatef.inspectFuncAnnotatef != nil {
		mmAnnotatef.inspectFuncAnnotatef(attributes, format, a...)
	}

	mm_params := &SpanInterfaceMockAnnotatefParams{attributes, format, a}

	// Record call args
	mmAnnotatef.AnnotatefMock.mutex.Lock()
	mmAnnotatef.AnnotatefMock.callArgs = append(mmAnnotatef.AnnotatefMock.callArgs, mm_params)
	mmAnnotatef.AnnotatefMock.mutex.Unlock()

	for _, e := range mmAnnotatef.AnnotatefMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAnnotatef.AnnotatefMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAnnotatef.AnnotatefMock.defaultExpectation.Counter, 1)
		mm_want := mmAnnotatef.AnnotatefMock.defaultExpectation.params
		mm_got := SpanInterfaceMockAnnotatefParams{attributes, format, a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAnnotatef.t.Errorf("SpanInterfaceMock.Annotatef got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAnnotatef.funcAnnotatef != nil {
		mmAnnotatef.funcAnnotatef(attributes, format, a...)
		return
	}
	mmAnnotatef.t.Fatalf("Unexpected call to SpanInterfaceMock.Annotatef. %v %v %v", attributes, format, a)

}

// AnnotatefAfterCounter returns a count of finished SpanInterfaceMock.Annotatef invocations
func (mmAnnotatef *SpanInterfaceMock) AnnotatefAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAnnotatef.afterAnnotatefCounter)
}

// AnnotatefBeforeCounter returns a count of SpanInterfaceMock.Annotatef invocations
func (mmAnnotatef *SpanInterfaceMock) AnnotatefBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAnnotatef.beforeAnnotatefCounter)
}

// Calls returns a list of arguments used in each call to SpanInterfaceMock.Annotatef.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAnnotatef *mSpanInterfaceMockAnnotatef) Calls() []*SpanInterfaceMockAnnotatefParams {
	mmAnnotatef.mutex.RLock()

	argCopy := make([]*SpanInterfaceMockAnnotatefParams, len(mmAnnotatef.callArgs))
	copy(argCopy, mmAnnotatef.callArgs)

	mmAnnotatef.mutex.RUnlock()

	return argCopy
}

// MinimockAnnotatefDone returns true if the count of the Annotatef invocations corresponds
// the number of defined expectations
func (m *SpanInterfaceMock) MinimockAnnotatefDone() bool {
	for _, e := range m.AnnotatefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AnnotatefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAnnotatefCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAnnotatef != nil && mm_atomic.LoadUint64(&m.afterAnnotatefCounter) < 1 {
		return false
	}
	return true
}

// MinimockAnnotatefInspect logs each unmet expectation
func (m *SpanInterfaceMock) MinimockAnnotatefInspect() {
	for _, e := range m.AnnotatefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpanInterfaceMock.Annotatef with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AnnotatefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAnnotatefCounter) < 1 {
		if m.AnnotatefMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SpanInterfaceMock.Annotatef")
		} else {
			m.t.Errorf("Expected call to SpanInterfaceMock.Annotatef with params: %#v", *m.AnnotatefMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAnnotatef != nil && mm_atomic.LoadUint64(&m.afterAnnotatefCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.Annotatef")
	}
}

type mSpanInterfaceMockEnd struct {
	mock               *SpanInterfaceMock
	defaultExpectation *SpanInterfaceMockEndExpectation
	expectations       []*SpanInterfaceMockEndExpectation
}

// SpanInterfaceMockEndExpectation specifies expectation struct of the SpanInterface.End
type SpanInterfaceMockEndExpectation struct {
	mock *SpanInterfaceMock

	Counter uint64
}

// Expect sets up expected params for SpanInterface.End
func (mmEnd *mSpanInterfaceMockEnd) Expect() *mSpanInterfaceMockEnd {
	if mmEnd.mock.funcEnd != nil {
		mmEnd.mock.t.Fatalf("SpanInterfaceMock.End mock is already set by Set")
	}

	if mmEnd.defaultExpectation == nil {
		mmEnd.defaultExpectation = &SpanInterfaceMockEndExpectation{}
	}

	return mmEnd
}

// Inspect accepts an inspector function that has same arguments as the SpanInterface.End
func (mmEnd *mSpanInterfaceMockEnd) Inspect(f func()) *mSpanInterfaceMockEnd {
	if mmEnd.mock.inspectFuncEnd != nil {
		mmEnd.mock.t.Fatalf("Inspect function is already set for SpanInterfaceMock.End")
	}

	mmEnd.mock.inspectFuncEnd = f

	return mmEnd
}

// Return sets up results that will be returned by SpanInterface.End
func (mmEnd *mSpanInterfaceMockEnd) Return() *SpanInterfaceMock {
	if mmEnd.mock.funcEnd != nil {
		mmEnd.mock.t.Fatalf("SpanInterfaceMock.End mock is already set by Set")
	}

	if mmEnd.defaultExpectation == nil {
		mmEnd.defaultExpectation = &SpanInterfaceMockEndExpectation{mock: mmEnd.mock}
	}

	return mmEnd.mock
}

//Set uses given function f to mock the SpanInterface.End method
func (mmEnd *mSpanInterfaceMockEnd) Set(f func()) *SpanInterfaceMock {
	if mmEnd.defaultExpectation != nil {
		mmEnd.mock.t.Fatalf("Default expectation is already set for the SpanInterface.End method")
	}

	if len(mmEnd.expectations) > 0 {
		mmEnd.mock.t.Fatalf("Some expectations are already set for the SpanInterface.End method")
	}

	mmEnd.mock.funcEnd = f
	return mmEnd.mock
}

// End implements trace.SpanInterface
func (mmEnd *SpanInterfaceMock) End() {
	mm_atomic.AddUint64(&mmEnd.beforeEndCounter, 1)
	defer mm_atomic.AddUint64(&mmEnd.afterEndCounter, 1)

	if mmEnd.inspectFuncEnd != nil {
		mmEnd.inspectFuncEnd()
	}

	if mmEnd.EndMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEnd.EndMock.defaultExpectation.Counter, 1)

		return

	}
	if mmEnd.funcEnd != nil {
		mmEnd.funcEnd()
		return
	}
	mmEnd.t.Fatalf("Unexpected call to SpanInterfaceMock.End.")

}

// EndAfterCounter returns a count of finished SpanInterfaceMock.End invocations
func (mmEnd *SpanInterfaceMock) EndAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnd.afterEndCounter)
}

// EndBeforeCounter returns a count of SpanInterfaceMock.End invocations
func (mmEnd *SpanInterfaceMock) EndBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnd.beforeEndCounter)
}

// MinimockEndDone returns true if the count of the End invocations corresponds
// the number of defined expectations
func (m *SpanInterfaceMock) MinimockEndDone() bool {
	for _, e := range m.EndMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EndMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEndCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnd != nil && mm_atomic.LoadUint64(&m.afterEndCounter) < 1 {
		return false
	}
	return true
}

// MinimockEndInspect logs each unmet expectation
func (m *SpanInterfaceMock) MinimockEndInspect() {
	for _, e := range m.EndMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SpanInterfaceMock.End")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EndMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEndCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.End")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnd != nil && mm_atomic.LoadUint64(&m.afterEndCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.End")
	}
}

type mSpanInterfaceMockIsRecordingEvents struct {
	mock               *SpanInterfaceMock
	defaultExpectation *SpanInterfaceMockIsRecordingEventsExpectation
	expectations       []*SpanInterfaceMockIsRecordingEventsExpectation
}

// SpanInterfaceMockIsRecordingEventsExpectation specifies expectation struct of the SpanInterface.IsRecordingEvents
type SpanInterfaceMockIsRecordingEventsExpectation struct {
	mock *SpanInterfaceMock

	results *SpanInterfaceMockIsRecordingEventsResults
	Counter uint64
}

// SpanInterfaceMockIsRecordingEventsResults contains results of the SpanInterface.IsRecordingEvents
type SpanInterfaceMockIsRecordingEventsResults struct {
	b1 bool
}

// Expect sets up expected params for SpanInterface.IsRecordingEvents
func (mmIsRecordingEvents *mSpanInterfaceMockIsRecordingEvents) Expect() *mSpanInterfaceMockIsRecordingEvents {
	if mmIsRecordingEvents.mock.funcIsRecordingEvents != nil {
		mmIsRecordingEvents.mock.t.Fatalf("SpanInterfaceMock.IsRecordingEvents mock is already set by Set")
	}

	if mmIsRecordingEvents.defaultExpectation == nil {
		mmIsRecordingEvents.defaultExpectation = &SpanInterfaceMockIsRecordingEventsExpectation{}
	}

	return mmIsRecordingEvents
}

// Inspect accepts an inspector function that has same arguments as the SpanInterface.IsRecordingEvents
func (mmIsRecordingEvents *mSpanInterfaceMockIsRecordingEvents) Inspect(f func()) *mSpanInterfaceMockIsRecordingEvents {
	if mmIsRecordingEvents.mock.inspectFuncIsRecordingEvents != nil {
		mmIsRecordingEvents.mock.t.Fatalf("Inspect function is already set for SpanInterfaceMock.IsRecordingEvents")
	}

	mmIsRecordingEvents.mock.inspectFuncIsRecordingEvents = f

	return mmIsRecordingEvents
}

// Return sets up results that will be returned by SpanInterface.IsRecordingEvents
func (mmIsRecordingEvents *mSpanInterfaceMockIsRecordingEvents) Return(b1 bool) *SpanInterfaceMock {
	if mmIsRecordingEvents.mock.funcIsRecordingEvents != nil {
		mmIsRecordingEvents.mock.t.Fatalf("SpanInterfaceMock.IsRecordingEvents mock is already set by Set")
	}

	if mmIsRecordingEvents.defaultExpectation == nil {
		mmIsRecordingEvents.defaultExpectation = &SpanInterfaceMockIsRecordingEventsExpectation{mock: mmIsRecordingEvents.mock}
	}
	mmIsRecordingEvents.defaultExpectation.results = &SpanInterfaceMockIsRecordingEventsResults{b1}
	return mmIsRecordingEvents.mock
}

//Set uses given function f to mock the SpanInterface.IsRecordingEvents method
func (mmIsRecordingEvents *mSpanInterfaceMockIsRecordingEvents) Set(f func() (b1 bool)) *SpanInterfaceMock {
	if mmIsRecordingEvents.defaultExpectation != nil {
		mmIsRecordingEvents.mock.t.Fatalf("Default expectation is already set for the SpanInterface.IsRecordingEvents method")
	}

	if len(mmIsRecordingEvents.expectations) > 0 {
		mmIsRecordingEvents.mock.t.Fatalf("Some expectations are already set for the SpanInterface.IsRecordingEvents method")
	}

	mmIsRecordingEvents.mock.funcIsRecordingEvents = f
	return mmIsRecordingEvents.mock
}

// IsRecordingEvents implements trace.SpanInterface
func (mmIsRecordingEvents *SpanInterfaceMock) IsRecordingEvents() (b1 bool) {
	mm_atomic.AddUint64(&mmIsRecordingEvents.beforeIsRecordingEventsCounter, 1)
	defer mm_atomic.AddUint64(&mmIsRecordingEvents.afterIsRecordingEventsCounter, 1)

	if mmIsRecordingEvents.inspectFuncIsRecordingEvents != nil {
		mmIsRecordingEvents.inspectFuncIsRecordingEvents()
	}

	if mmIsRecordingEvents.IsRecordingEventsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsRecordingEvents.IsRecordingEventsMock.defaultExpectation.Counter, 1)

		mm_results := mmIsRecordingEvents.IsRecordingEventsMock.defaultExpectation.results
		if mm_results == nil {
			mmIsRecordingEvents.t.Fatal("No results are set for the SpanInterfaceMock.IsRecordingEvents")
		}
		return (*mm_results).b1
	}
	if mmIsRecordingEvents.funcIsRecordingEvents != nil {
		return mmIsRecordingEvents.funcIsRecordingEvents()
	}
	mmIsRecordingEvents.t.Fatalf("Unexpected call to SpanInterfaceMock.IsRecordingEvents.")
	return
}

// IsRecordingEventsAfterCounter returns a count of finished SpanInterfaceMock.IsRecordingEvents invocations
func (mmIsRecordingEvents *SpanInterfaceMock) IsRecordingEventsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRecordingEvents.afterIsRecordingEventsCounter)
}

// IsRecordingEventsBeforeCounter returns a count of SpanInterfaceMock.IsRecordingEvents invocations
func (mmIsRecordingEvents *SpanInterfaceMock) IsRecordingEventsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRecordingEvents.beforeIsRecordingEventsCounter)
}

// MinimockIsRecordingEventsDone returns true if the count of the IsRecordingEvents invocations corresponds
// the number of defined expectations
func (m *SpanInterfaceMock) MinimockIsRecordingEventsDone() bool {
	for _, e := range m.IsRecordingEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsRecordingEventsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsRecordingEventsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsRecordingEvents != nil && mm_atomic.LoadUint64(&m.afterIsRecordingEventsCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsRecordingEventsInspect logs each unmet expectation
func (m *SpanInterfaceMock) MinimockIsRecordingEventsInspect() {
	for _, e := range m.IsRecordingEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SpanInterfaceMock.IsRecordingEvents")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsRecordingEventsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsRecordingEventsCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.IsRecordingEvents")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsRecordingEvents != nil && mm_atomic.LoadUint64(&m.afterIsRecordingEventsCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.IsRecordingEvents")
	}
}

type mSpanInterfaceMockSetName struct {
	mock               *SpanInterfaceMock
	defaultExpectation *SpanInterfaceMockSetNameExpectation
	expectations       []*SpanInterfaceMockSetNameExpectation

	callArgs []*SpanInterfaceMockSetNameParams
	mutex    sync.RWMutex
}

// SpanInterfaceMockSetNameExpectation specifies expectation struct of the SpanInterface.SetName
type SpanInterfaceMockSetNameExpectation struct {
	mock   *SpanInterfaceMock
	params *SpanInterfaceMockSetNameParams

	Counter uint64
}

// SpanInterfaceMockSetNameParams contains parameters of the SpanInterface.SetName
type SpanInterfaceMockSetNameParams struct {
	name string
}

// Expect sets up expected params for SpanInterface.SetName
func (mmSetName *mSpanInterfaceMockSetName) Expect(name string) *mSpanInterfaceMockSetName {
	if mmSetName.mock.funcSetName != nil {
		mmSetName.mock.t.Fatalf("SpanInterfaceMock.SetName mock is already set by Set")
	}

	if mmSetName.defaultExpectation == nil {
		mmSetName.defaultExpectation = &SpanInterfaceMockSetNameExpectation{}
	}

	mmSetName.defaultExpectation.params = &SpanInterfaceMockSetNameParams{name}
	for _, e := range mmSetName.expectations {
		if minimock.Equal(e.params, mmSetName.defaultExpectation.params) {
			mmSetName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetName.defaultExpectation.params)
		}
	}

	return mmSetName
}

// Inspect accepts an inspector function that has same arguments as the SpanInterface.SetName
func (mmSetName *mSpanInterfaceMockSetName) Inspect(f func(name string)) *mSpanInterfaceMockSetName {
	if mmSetName.mock.inspectFuncSetName != nil {
		mmSetName.mock.t.Fatalf("Inspect function is already set for SpanInterfaceMock.SetName")
	}

	mmSetName.mock.inspectFuncSetName = f

	return mmSetName
}

// Return sets up results that will be returned by SpanInterface.SetName
func (mmSetName *mSpanInterfaceMockSetName) Return() *SpanInterfaceMock {
	if mmSetName.mock.funcSetName != nil {
		mmSetName.mock.t.Fatalf("SpanInterfaceMock.SetName mock is already set by Set")
	}

	if mmSetName.defaultExpectation == nil {
		mmSetName.defaultExpectation = &SpanInterfaceMockSetNameExpectation{mock: mmSetName.mock}
	}

	return mmSetName.mock
}

//Set uses given function f to mock the SpanInterface.SetName method
func (mmSetName *mSpanInterfaceMockSetName) Set(f func(name string)) *SpanInterfaceMock {
	if mmSetName.defaultExpectation != nil {
		mmSetName.mock.t.Fatalf("Default expectation is already set for the SpanInterface.SetName method")
	}

	if len(mmSetName.expectations) > 0 {
		mmSetName.mock.t.Fatalf("Some expectations are already set for the SpanInterface.SetName method")
	}

	mmSetName.mock.funcSetName = f
	return mmSetName.mock
}

// SetName implements trace.SpanInterface
func (mmSetName *SpanInterfaceMock) SetName(name string) {
	mm_atomic.AddUint64(&mmSetName.beforeSetNameCounter, 1)
	defer mm_atomic.AddUint64(&mmSetName.afterSetNameCounter, 1)

	if mmSetName.inspectFuncSetName != nil {
		mmSetName.inspectFuncSetName(name)
	}

	mm_params := &SpanInterfaceMockSetNameParams{name}

	// Record call args
	mmSetName.SetNameMock.mutex.Lock()
	mmSetName.SetNameMock.callArgs = append(mmSetName.SetNameMock.callArgs, mm_params)
	mmSetName.SetNameMock.mutex.Unlock()

	for _, e := range mmSetName.SetNameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetName.SetNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetName.SetNameMock.defaultExpectation.Counter, 1)
		mm_want := mmSetName.SetNameMock.defaultExpectation.params
		mm_got := SpanInterfaceMockSetNameParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetName.t.Errorf("SpanInterfaceMock.SetName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetName.funcSetName != nil {
		mmSetName.funcSetName(name)
		return
	}
	mmSetName.t.Fatalf("Unexpected call to SpanInterfaceMock.SetName. %v", name)

}

// SetNameAfterCounter returns a count of finished SpanInterfaceMock.SetName invocations
func (mmSetName *SpanInterfaceMock) SetNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetName.afterSetNameCounter)
}

// SetNameBeforeCounter returns a count of SpanInterfaceMock.SetName invocations
func (mmSetName *SpanInterfaceMock) SetNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetName.beforeSetNameCounter)
}

// Calls returns a list of arguments used in each call to SpanInterfaceMock.SetName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetName *mSpanInterfaceMockSetName) Calls() []*SpanInterfaceMockSetNameParams {
	mmSetName.mutex.RLock()

	argCopy := make([]*SpanInterfaceMockSetNameParams, len(mmSetName.callArgs))
	copy(argCopy, mmSetName.callArgs)

	mmSetName.mutex.RUnlock()

	return argCopy
}

// MinimockSetNameDone returns true if the count of the SetName invocations corresponds
// the number of defined expectations
func (m *SpanInterfaceMock) MinimockSetNameDone() bool {
	for _, e := range m.SetNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetName != nil && mm_atomic.LoadUint64(&m.afterSetNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetNameInspect logs each unmet expectation
func (m *SpanInterfaceMock) MinimockSetNameInspect() {
	for _, e := range m.SetNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpanInterfaceMock.SetName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetNameCounter) < 1 {
		if m.SetNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SpanInterfaceMock.SetName")
		} else {
			m.t.Errorf("Expected call to SpanInterfaceMock.SetName with params: %#v", *m.SetNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetName != nil && mm_atomic.LoadUint64(&m.afterSetNameCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.SetName")
	}
}

type mSpanInterfaceMockSetStatus struct {
	mock               *SpanInterfaceMock
	defaultExpectation *SpanInterfaceMockSetStatusExpectation
	expectations       []*SpanInterfaceMockSetStatusExpectation

	callArgs []*SpanInterfaceMockSetStatusParams
	mutex    sync.RWMutex
}

// SpanInterfaceMockSetStatusExpectation specifies expectation struct of the SpanInterface.SetStatus
type SpanInterfaceMockSetStatusExpectation struct {
	mock   *SpanInterfaceMock
	params *SpanInterfaceMockSetStatusParams

	Counter uint64
}

// SpanInterfaceMockSetStatusParams contains parameters of the SpanInterface.SetStatus
type SpanInterfaceMockSetStatusParams struct {
	status mm_trace.Status
}

// Expect sets up expected params for SpanInterface.SetStatus
func (mmSetStatus *mSpanInterfaceMockSetStatus) Expect(status mm_trace.Status) *mSpanInterfaceMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("SpanInterfaceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &SpanInterfaceMockSetStatusExpectation{}
	}

	mmSetStatus.defaultExpectation.params = &SpanInterfaceMockSetStatusParams{status}
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the SpanInterface.SetStatus
func (mmSetStatus *mSpanInterfaceMockSetStatus) Inspect(f func(status mm_trace.Status)) *mSpanInterfaceMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for SpanInterfaceMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by SpanInterface.SetStatus
func (mmSetStatus *mSpanInterfaceMockSetStatus) Return() *SpanInterfaceMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("SpanInterfaceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &SpanInterfaceMockSetStatusExpectation{mock: mmSetStatus.mock}
	}

	return mmSetStatus.mock
}

//Set uses given function f to mock the SpanInterface.SetStatus method
func (mmSetStatus *mSpanInterfaceMockSetStatus) Set(f func(status mm_trace.Status)) *SpanInterfaceMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the SpanInterface.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the SpanInterface.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	return mmSetStatus.mock
}

// SetStatus implements trace.SpanInterface
func (mmSetStatus *SpanInterfaceMock) SetStatus(status mm_trace.Status) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(status)
	}

	mm_params := &SpanInterfaceMockSetStatusParams{status}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_got := SpanInterfaceMockSetStatusParams{status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("SpanInterfaceMock.SetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetStatus.funcSetStatus != nil {
		mmSetStatus.funcSetStatus(status)
		return
	}
	mmSetStatus.t.Fatalf("Unexpected call to SpanInterfaceMock.SetStatus. %v", status)

}

// SetStatusAfterCounter returns a count of finished SpanInterfaceMock.SetStatus invocations
func (mmSetStatus *SpanInterfaceMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of SpanInterfaceMock.SetStatus invocations
func (mmSetStatus *SpanInterfaceMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to SpanInterfaceMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mSpanInterfaceMockSetStatus) Calls() []*SpanInterfaceMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*SpanInterfaceMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *SpanInterfaceMock) MinimockSetStatusDone() bool {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *SpanInterfaceMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SpanInterfaceMock.SetStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SpanInterfaceMock.SetStatus")
		} else {
			m.t.Errorf("Expected call to SpanInterfaceMock.SetStatus with params: %#v", *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.SetStatus")
	}
}

type mSpanInterfaceMockSpanContext struct {
	mock               *SpanInterfaceMock
	defaultExpectation *SpanInterfaceMockSpanContextExpectation
	expectations       []*SpanInterfaceMockSpanContextExpectation
}

// SpanInterfaceMockSpanContextExpectation specifies expectation struct of the SpanInterface.SpanContext
type SpanInterfaceMockSpanContextExpectation struct {
	mock *SpanInterfaceMock

	results *SpanInterfaceMockSpanContextResults
	Counter uint64
}

// SpanInterfaceMockSpanContextResults contains results of the SpanInterface.SpanContext
type SpanInterfaceMockSpanContextResults struct {
	s1 mm_trace.SpanContext
}

// Expect sets up expected params for SpanInterface.SpanContext
func (mmSpanContext *mSpanInterfaceMockSpanContext) Expect() *mSpanInterfaceMockSpanContext {
	if mmSpanContext.mock.funcSpanContext != nil {
		mmSpanContext.mock.t.Fatalf("SpanInterfaceMock.SpanContext mock is already set by Set")
	}

	if mmSpanContext.defaultExpectation == nil {
		mmSpanContext.defaultExpectation = &SpanInterfaceMockSpanContextExpectation{}
	}

	return mmSpanContext
}

// Inspect accepts an inspector function that has same arguments as the SpanInterface.SpanContext
func (mmSpanContext *mSpanInterfaceMockSpanContext) Inspect(f func()) *mSpanInterfaceMockSpanContext {
	if mmSpanContext.mock.inspectFuncSpanContext != nil {
		mmSpanContext.mock.t.Fatalf("Inspect function is already set for SpanInterfaceMock.SpanContext")
	}

	mmSpanContext.mock.inspectFuncSpanContext = f

	return mmSpanContext
}

// Return sets up results that will be returned by SpanInterface.SpanContext
func (mmSpanContext *mSpanInterfaceMockSpanContext) Return(s1 mm_trace.SpanContext) *SpanInterfaceMock {
	if mmSpanContext.mock.funcSpanContext != nil {
		mmSpanContext.mock.t.Fatalf("SpanInterfaceMock.SpanContext mock is already set by Set")
	}

	if mmSpanContext.defaultExpectation == nil {
		mmSpanContext.defaultExpectation = &SpanInterfaceMockSpanContextExpectation{mock: mmSpanContext.mock}
	}
	mmSpanContext.defaultExpectation.results = &SpanInterfaceMockSpanContextResults{s1}
	return mmSpanContext.mock
}

//Set uses given function f to mock the SpanInterface.SpanContext method
func (mmSpanContext *mSpanInterfaceMockSpanContext) Set(f func() (s1 mm_trace.SpanContext)) *SpanInterfaceMock {
	if mmSpanContext.defaultExpectation != nil {
		mmSpanContext.mock.t.Fatalf("Default expectation is already set for the SpanInterface.SpanContext method")
	}

	if len(mmSpanContext.expectations) > 0 {
		mmSpanContext.mock.t.Fatalf("Some expectations are already set for the SpanInterface.SpanContext method")
	}

	mmSpanContext.mock.funcSpanContext = f
	return mmSpanContext.mock
}

// SpanContext implements trace.SpanInterface
func (mmSpanContext *SpanInterfaceMock) SpanContext() (s1 mm_trace.SpanContext) {
	mm_atomic.AddUint64(&mmSpanContext.beforeSpanContextCounter, 1)
	defer mm_atomic.AddUint64(&mmSpanContext.afterSpanContextCounter, 1)

	if mmSpanContext.inspectFuncSpanContext != nil {
		mmSpanContext.inspectFuncSpanContext()
	}

	if mmSpanContext.SpanContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSpanContext.SpanContextMock.defaultExpectation.Counter, 1)

		mm_results := mmSpanContext.SpanContextMock.defaultExpectation.results
		if mm_results == nil {
			mmSpanContext.t.Fatal("No results are set for the SpanInterfaceMock.SpanContext")
		}
		return (*mm_results).s1
	}
	if mmSpanContext.funcSpanContext != nil {
		return mmSpanContext.funcSpanContext()
	}
	mmSpanContext.t.Fatalf("Unexpected call to SpanInterfaceMock.SpanContext.")
	return
}

// SpanContextAfterCounter returns a count of finished SpanInterfaceMock.SpanContext invocations
func (mmSpanContext *SpanInterfaceMock) SpanContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSpanContext.afterSpanContextCounter)
}

// SpanContextBeforeCounter returns a count of SpanInterfaceMock.SpanContext invocations
func (mmSpanContext *SpanInterfaceMock) SpanContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSpanContext.beforeSpanContextCounter)
}

// MinimockSpanContextDone returns true if the count of the SpanContext invocations corresponds
// the number of defined expectations
func (m *SpanInterfaceMock) MinimockSpanContextDone() bool {
	for _, e := range m.SpanContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SpanContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSpanContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSpanContext != nil && mm_atomic.LoadUint64(&m.afterSpanContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockSpanContextInspect logs each unmet expectation
func (m *SpanInterfaceMock) MinimockSpanContextInspect() {
	for _, e := range m.SpanContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SpanInterfaceMock.SpanContext")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SpanContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSpanContextCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.SpanContext")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSpanContext != nil && mm_atomic.LoadUint64(&m.afterSpanContextCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.SpanContext")
	}
}

type mSpanInterfaceMockString struct {
	mock               *SpanInterfaceMock
	defaultExpectation *SpanInterfaceMockStringExpectation
	expectations       []*SpanInterfaceMockStringExpectation
}

// SpanInterfaceMockStringExpectation specifies expectation struct of the SpanInterface.String
type SpanInterfaceMockStringExpectation struct {
	mock *SpanInterfaceMock

	results *SpanInterfaceMockStringResults
	Counter uint64
}

// SpanInterfaceMockStringResults contains results of the SpanInterface.String
type SpanInterfaceMockStringResults struct {
	s1 string
}

// Expect sets up expected params for SpanInterface.String
func (mmString *mSpanInterfaceMockString) Expect() *mSpanInterfaceMockString {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("SpanInterfaceMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &SpanInterfaceMockStringExpectation{}
	}

	return mmString
}

// Inspect accepts an inspector function that has same arguments as the SpanInterface.String
func (mmString *mSpanInterfaceMockString) Inspect(f func()) *mSpanInterfaceMockString {
	if mmString.mock.inspectFuncString != nil {
		mmString.mock.t.Fatalf("Inspect function is already set for SpanInterfaceMock.String")
	}

	mmString.mock.inspectFuncString = f

	return mmString
}

// Return sets up results that will be returned by SpanInterface.String
func (mmString *mSpanInterfaceMockString) Return(s1 string) *SpanInterfaceMock {
	if mmString.mock.funcString != nil {
		mmString.mock.t.Fatalf("SpanInterfaceMock.String mock is already set by Set")
	}

	if mmString.defaultExpectation == nil {
		mmString.defaultExpectation = &SpanInterfaceMockStringExpectation{mock: mmString.mock}
	}
	mmString.defaultExpectation.results = &SpanInterfaceMockStringResults{s1}
	return mmString.mock
}

//Set uses given function f to mock the SpanInterface.String method
func (mmString *mSpanInterfaceMockString) Set(f func() (s1 string)) *SpanInterfaceMock {
	if mmString.defaultExpectation != nil {
		mmString.mock.t.Fatalf("Default expectation is already set for the SpanInterface.String method")
	}

	if len(mmString.expectations) > 0 {
		mmString.mock.t.Fatalf("Some expectations are already set for the SpanInterface.String method")
	}

	mmString.mock.funcString = f
	return mmString.mock
}

// String implements trace.SpanInterface
func (mmString *SpanInterfaceMock) String() (s1 string) {
	mm_atomic.AddUint64(&mmString.beforeStringCounter, 1)
	defer mm_atomic.AddUint64(&mmString.afterStringCounter, 1)

	if mmString.inspectFuncString != nil {
		mmString.inspectFuncString()
	}

	if mmString.StringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmString.StringMock.defaultExpectation.Counter, 1)

		mm_results := mmString.StringMock.defaultExpectation.results
		if mm_results == nil {
			mmString.t.Fatal("No results are set for the SpanInterfaceMock.String")
		}
		return (*mm_results).s1
	}
	if mmString.funcString != nil {
		return mmString.funcString()
	}
	mmString.t.Fatalf("Unexpected call to SpanInterfaceMock.String.")
	return
}

// StringAfterCounter returns a count of finished SpanInterfaceMock.String invocations
func (mmString *SpanInterfaceMock) StringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.afterStringCounter)
}

// StringBeforeCounter returns a count of SpanInterfaceMock.String invocations
func (mmString *SpanInterfaceMock) StringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmString.beforeStringCounter)
}

// MinimockStringDone returns true if the count of the String invocations corresponds
// the number of defined expectations
func (m *SpanInterfaceMock) MinimockStringDone() bool {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockStringInspect logs each unmet expectation
func (m *SpanInterfaceMock) MinimockStringInspect() {
	for _, e := range m.StringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SpanInterfaceMock.String")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.String")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcString != nil && mm_atomic.LoadUint64(&m.afterStringCounter) < 1 {
		m.t.Error("Expected call to SpanInterfaceMock.String")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SpanInterfaceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddAttributesInspect()

		m.MinimockAddLinkInspect()

		m.MinimockAddMessageReceiveEventInspect()

		m.MinimockAddMessageSendEventInspect()

		m.MinimockAnnotateInspect()

		m.MinimockAnnotatefInspect()

		m.MinimockEndInspect()

		m.MinimockIsRecordingEventsInspect()

		m.MinimockSetNameInspect()

		m.MinimockSetStatusInspect()

		m.MinimockSpanContextInspect()

		m.MinimockStringInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SpanInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SpanInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddAttributesDone() &&
		m.MinimockAddLinkDone() &&
		m.MinimockAddMessageReceiveEventDone() &&
		m.MinimockAddMessageSendEventDone() &&
		m.MinimockAnnotateDone() &&
		m.MinimockAnnotatefDone() &&
		m.MinimockEndDone() &&
		m.MinimockIsRecordingEventsDone() &&
		m.MinimockSetNameDone() &&
		m.MinimockSetStatusDone() &&
		m.MinimockSpanContextDone() &&
		m.MinimockStringDone()
}
